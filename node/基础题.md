nodejs为何不适合CPU密集型而适合I/O密集型  
  1、因为 NodeJs 执行是单线程的，如果执行 CPU 密集的任务就会阻塞后续代码，且单线程无法充分利用 CPU 多核资源。而异步 I/O 是多线程的，在工作线程上执行，不会阻塞执行线程。当然 NodeJS 也可以通过 child_process 等方式，启用多进程或多线程来处理 CPU 密集型的任务，但相比其它成熟的方案并没有任何优势。  
  2、因为nodejs是事件驱动的机制，利用异步回调，处理事件的能力可以不用多线程的调用  
  
# 如何防止大量数据爬虫  
  1、权限控制，未登录 不可见；  
  2、对请求源头进行记录控制，一定时间内控制请求数；  
  3、对链接进行权限控制和验证，类似百度云盘一样查看分享连接时需要验证；  
  
# 布隆过滤器  
  实际上是一个很长的二进制向量和一系列随机映射函数，hash的底层实现；  
  
# 线上服务的高并发如何保证（含限流方案）  
  1、简单方案，计数器+固定窗口限流，因为设计较简单，会有很多不足和问题；  
  2、令牌桶算法，当每个请求到来时，首先去 token 桶中获取 token，如果获取到则执行并移除一个 token，否则丢弃此次请求（会出现请求丢失）；同时存在一个定时器，在每个单位时间向 token 桶投递一定数量的 tokens，若最终 tokens 的总数超过上限 b，则会移除多余部分。  
  3、漏桶算法，即队列，强制一个常量的速度进行请求流量控制，缺点，效率不高；  
  4、多方面，例如负载均衡，限流（上面提到的解决方案），缓存，会通常结合令牌桶和漏桶算法使用；  
  
  
# 如何看nodejs可支持高并发  
  1、从线程上讲，单线程架构，并发真正的单线程架构，只是js代码在v8上是单线程的，还有I/O线程（网络，磁盘等），底层I/O线程由c++libuv处理，这些对开发者来说是不透明的，由于是单线程，没有线程切换的开销，没有线程冲突问题，劣势就是不能充分利用cpu资源，单线程一旦崩溃应用就挂了，因为单线程，一旦一个cpu被某个计算占用，cpu就得不到释放，后续操作就会被挂起无响应；  
  2、事件循环机制，和浏览器略微 差异，但是高版本中，已经和浏览器基本相同了（浏览器的eventloop是 h5中定义的，而node是libuv库定义的）；  
  3、结论nodejs是异步非阻塞的，所以能抗住高并发  
  4、同步，比如ajax同步alert，异步宏任务微任务， 非阻塞，比如事件  
  
# node如何创建子进程  
  1、cluster 模块可以创建共享服务器端口的子进程， fork创建子进程 ，  
  2、线程间如何传输数据parentPort，postMessage发送监听消息  
  3、共享内存： SharedArrayBuffer；  
  4、使用场景，需要用到shell命令，pm2等；  
  
# js较c++等语言慢，v8做了哪些优化  
  1、js 的问题，动态类型，动态类型导致存取属性和方法时，都需要先检查类型，也很难编译阶段进行优化；  
  2、在静态类型的语言中，属性数存储在数组中的，仅需数组唯一就可以获取，二JS存储在对象中，每次都要用hash插线  
  3、相较于其他语言，js一遍解释一遍执行，v8做了优化，一段代码若被多次执行，会将代码转为机器猫缓存，下次运行直接使用机器码；  
  4、隐藏类，v8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类；  
  5，内嵌缓存，及缓存对象查询的结果，过程是：获取隐藏类>>根据属性名查找偏移值>>计算改属性地址，内嵌缓存就是对这个过程结果的缓存；  
  6、垃圾回收管理；  