  # mysql事务、幻读  
  事务的4大特性：  
    1、原子性 事务是一个最小单位，不能再分开；  
    2、一致性  事务内所有的具体操作时，必须会同时成功或同时失败，提交 回滚；  
    3、隔离性 不同事务之前隔离；  
    4、持久性 事务执行的保证 会把内存数据持久化到硬盘内；  
  事务隔离级别  
    4个级别 后端的东西，里面可以讲的很多（非专业后端不需要掌握，了解即可），默认是可重复读；  
  幻读  
    指的是在一个事务内，同一SELECT语句在不同时间执行，得到不同的结果集时，就会发生所谓的幻读问题；  
    mysql解决幻读问题  
      快照读，mysql默认隔离级别是可重复读，事务开始，多次SELECT查询一条数据都是事务开始时的状态的数据，解决幻读；  
      undo log, 查询时判断这个数据与没有被加入行锁中，没有就直接读，有的话就是读取从undo log之前版本的数据， undo log是旧数据的备份；  
      实时读，（不在事务内时）就是查询时总是执行这个查询时数据库中的数据。  
  
# 数据库如何防止sql注入  
  1、预编译，对执行语句进行预编译，将占位符替换掉，例如myBatis，然后把攻击语句的符号改成其他；  
  2、控制数据类型；  
  3、对特殊字符进行转义对特定字符进行转移，或者用一些内置函数；  
  能力有限，还有很多方法；  
  
# mysql乐观锁和悲观锁  
  乐观锁  
    顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改这个数据，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有要去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。  
  悲观锁  
    并发情况下数据安全问题，就得用悲观锁（后端知识）；  
  
# redis如何实现消息队列  
  用redis的list数据结构, list类型(lpush和rpop或者brpop，rpush和lpop或者blpop， blpop和brpop是阻塞读取)，把消息用每一个key去保存，执行完了从头删掉，一般用阻塞形式，需要结合发布订阅一起实现；  
  如何处理消息丢失问题：    
    1、队列操作启用事务；  
    2、redis改配置，任何变更都进行实时的数据持久化（写入磁盘）；  
    3、消费消息在事务内进行，处理完再删消息；  
    4、多线程或多端消费消息可以用加锁的方式；  
  
# mysql和redis数据同步问题  
  即对一些数据做缓存，把mysql的数据更新到redis内，redis存放的是真实数据的副本  
  有多重方案，常见的  
    1、实时更新数据库，数据库数据变更时同时更新redis，既然是副本，那会存在数据不一致的情况；  
    2、缓存失效机制，失效的时候再设置缓存，失效瞬间可能引起缓存穿透，请求直接打到数据库，引起缓存穿透、雪崩；  
    3、定时器更新缓存，定时更新缓存，没有访问压力，但是数据的时效性较差；  
    根据不同业务场景使用合适的方案；  
  
# mysql慢查询排查  
  用相应的工具库或mysql命令，把数据库慢查询操作（设置超过多久为慢查询）记录下来，排查日志；  
  优化，加适当的索引（不然适得其反），衡量数据的重要性定期清理，join只用inner join（不使用外键）；  
  1、索引原理  
    索引是为了快速检索，mysql的索引需要额外的空间去维护，索引底层用了B+树实现，对快速检索有帮助；  
    底层数据使用了Innodb和Myisam,  
      Innodb是默认引擎，是为了处理事务，通过间隙锁防止幻读，用的最多；  
      Myisam不支持事务，因为不支持行级锁，只能整表加锁，但是查询性能更好；  
  2、索引优化  
    较频繁的作为查询条件的字段应该创建索引；  
    唯一性太差的字段不适合单独创建索引；  
    更新非常频繁的字段不适合创建索引。  
  