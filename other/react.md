# 生命周期  
    挂载前/后  
    更新前/后 更新时shouldComponentUpdate  
    卸载前/后  

# fiber 相关的  
    fiber代表了虚拟执行栈的任务单元；  
    官方介绍就是对核心diff算法的一次重新实现，对开发者来说感觉不到功能变化，只是性能更好了，现在都用hooks 没有历史包袱；  
    核心修改：  
      1、渲染的同步更新改为异步更新（js单线程运行，同步必然会执行阻塞浏览器每一帧的渲染，大量数据更新会造成视觉上的卡顿，所谓性能不好）；  
      2、渲染过程被匀到多帧，由算法中分析出任务的优先级，并且能中断和恢复，执行顺序从按优先级来，依次是文本输入、本次调度结束需要完成的任务、动画过渡、交互反馈、数据更新、最后是不会显示但是可能会显示的任务，  
      3、每次一调度结束或者被中断，会调用requestIdleCallback(一个优先级低的任务)/requestAnimationFrame(优先级高的任务)；  
      4、setState 不会立即渲染 而是根据执行上下文来收集state的变化，然后再更新；  
      5、看过很多人（包括一些大佬）对源码的分析，很多底层的细节 貌似每个人的理解好像都不太一样，理解能力上的偏差导致的，但是大概的结论是一致的；  
    
# 事件合成  
    react自己有一个实现了一个事件系统，事件池（V17移除了）把所有的事件注册收集起来，并用了插件机制来管理不同行为的事件，
    对事件的优先级进行了分类，只绑定一个事件到document上（v17版本绑定到挂载的根节点）；有些事件没有冒泡，则在捕获阶段进行事件委托；  
    e.persist()：如果要以异步方式访问事件属性，则应调用event.persist()事件，从事件池中删除事件，并允许用户代码保留对该事件的引用。  
  
# react 17  
    JSX转换，无需babel，react内置；  
    主要更改了事件委托，去除事件池， 副作用清理变成异步了，还有很多小的改动，基本不影响开发；  
    如果要使用最新版本相应的一些UI库也需要支持才行；  
  
# 虚拟Dom diff相关  
    虚拟dom：是个一反应真实dom数结构的数据，
    直接操作dom的性能开销是非常大的，通过对比虚拟dom，再反应到真实的dom上变化，这把性能开销降到最低；  
    diff算法：有3种策略  
      1、dom跨层级操作，比很少，忽略不计，react 对于这种操作简单粗暴，对同层级的虚拟dom比较，发现不同则直接增删 ；  
      2、组件对比，和dom跨层级操作类似，组件变不一样了，也是一样简单粗暴的的操作；  
      3、一个父组件内子组件元素的移动、插入、删除操作，这些子组件运行开发者加一个key属性，让diff算出消耗最少的操作步数，具体就是；  
  
# 受控、非受控组件   
    一些表单元素标签其输入收到控制，只能 setState 来控制更新，为受控；  
    非受控，显示不受setState控制，由dom本身去处理，ref.xxx取到值  
  
# react hooks相关  
    step1：为什么要是使用hooks  
      函数式，没有this的负担；  
      更容易复用代码，class复用方式是 高阶组件和  renderProps， 用hooks实现更简单，代码量更少；  
        例子，一个带分页内容的table， 有size/page/data等值，class组件抽离这些状态要写一个高阶函数，把这些数据包一下再返回一个组件； hooks直接抽离这些值到一个函数内，在函数内处理；  
      状态分离，class组件设置状态就一个setState, hooks可以细分这些状态, 逻辑更清晰，这样就容易被复用了；  
    step2：遇到过哪些hooks的坑；  
      不要在一个useEffect依赖太多的值，细分依赖的监听；  
      state处理异步代码不太好，比如一个值常常需要更新，这是后用异步的去获取，可能会是不是我们想要的，之前的那个旧值，需要用一个useRef去同步保存，不太优雅，或者其他方式改业务实现逻辑啥的；  
      useEffect传入一个空数组时，在里面任何监听外面依赖值，都是原始值，无法获取到更新后的值；  
    step3：为什么useState会出现依赖异步获取值没法更新的问题、或useState实现原理  
      因为第一次渲染时，会把声明的useState一次存入一个数组中，这样hooks的访问顺序是固定的，如果放入循环或判断中，那么hooks的调用顺序就会出现错乱了；因为hooks更新渲染会把值以闭包的形式传入到组件内，值已经是固定的，所以异步去获取值还是原来的那个缓存值，不是最新的了；  
    step4：如何优化  
      抽取相同的，可以复用的状态，利用useMemo和useCallback缓存的特性；  
    step5：useLayoutEffect和useEffect的区别
      执行时机不同，前者在渲染前，后者在渲染后  
# redux和mobx  
    redux：订阅发布，核心实现用一个store存储状态，这个store状态存储着状态数，通过dispatch派发action行为更新store，组件内部通过订阅store中的状态state来刷新自己的视图。  
    mobx：可观察对象，底层对数据的观察，是使用Object.defineProperty或Proxy，get方法会被执行，此时可以进行依赖收集，将此函数加入到该Observable变量的依赖中，set的时通知相应的依赖去更新 组件；  

# 开发规范
    对于一些常用的组件，可以做进一步细分  
    1、组件可以封装成纯展示型的，逻辑层可以写在另一个地方，称容器组件，展示时用到展示组件；  
    2、展示组件应不含复杂逻辑和业务在内，保持职责单一的原则，仅有基本的试图呈现和基本的交互行为，容器组件可以传递props和回调来进一步封装展示组件，其实就是惯用了mvc模型，即视图和逻辑分离

# hooks中 setState
    简单方向， setState会把状态进行diff对比，找出不同的，然后更新；
    深入：
    1、setState后立即获取 state，值还是旧的那个，因为闭包值一旦传入，没有更改，需要在下一次组件更新才能获取到最新的值；
    2、要在下一次获取到最新的，setState可以接受一个函数，这个入参就是最新的state；
    3、setState后会不会立即更新，批量收集需要更新值，函数作为参数会依次把值传递下去，最后再更新；
    4、底层，区分异步更新和同步更新，
      同步更新的情况，定时器，手动添加的事件，promise.then后面的时候；
      异步，并发是由异步api实现，其实是一个更新的事务，setState一个值多次，取最后的，setState不同值，最后会合并进行一次批量更新；
    5、简单原理 ，每次执行把新的state存入等待更新队列中，判断当前是否需要批量更新，是的话就把要组件放入待更新队列中，
      batchedUpdates，更新事务，其实可以理解成类似数据库的事务，找出需要更新的dom， 最后一次性做完；
      不受控制的就是同步更新的情况；
    
# wrappedComponentRef和ref的区别
    1、前者用于父组件获取高阶组件处理后的子组件的引用
    2、后者是父组件获取非高阶组件获取子组件的引用
    
# 优化方向
    1、memo、 useCallback、 useMemo
    2、减少render次数，state仅存放只渲染的数据，其他放useRef里
    3、合理的组件拆分，开发中体会
    4、使用渲染组件，及纯渲染，没有内部的state
    5、节流和防抖
    6、使用webWork分散处理cpu密集型任务，可以开启多个
    7、IntersectionObserver 隐藏不在视窗内的内容，虚拟滚动，表单类组件会导致bug
    8、切忌不要过度优化，过度优化是万恶之源，一定要根据业务指标去做针对性的优化

# hooks为什么没有生命周期
    因为hooks本质是函数，不存在生命周期这个一说，但是可以用 useEffect去模拟
    componentDidMount useEffect 第二个参数为空
    shouldComponentUpdate 用React.memo的第二个参数 比较前一个状态和下一个状态
    componentDidUpdate useEffect 第二个参数不传递即可
    componentWillUnmount   useEffect 第二个参数为空或者不传递，并返回一个函数

# unsafe类生命周期有生命问题
    componentWillMount、componentWillReceiveProps、componentWillUpdate在16版本以后被取消了，在17版本证书被删除了
    其实hooks也有这样的递归问题，比如在useEffet里监听了一个state变化后，又去改变这个state，这样就会无限循环，递归溢出
