# 事件循环  
  step1：为什么有时间循环的机制  
    js运行时单线程的，需要一个并发模型，事件循环负责执行代码，收集和处理事件并执行队列中的任务；  
  step2：事件循环详解  
    js代码执行是一个执行栈，执行栈对根据上下文运行代码，遇到异步任务就先兑入任务队列，任务队列分宏任务和微任务，宏任务定时器、requestAnimationFrame、微任务:promise.then收集的回调函数 MutaionObserver，queueMicrotask, process.nextTick；  
    执行栈执行完毕后，会立即处理微任务队列中的事件。然后从宏任务队列中取出一个事件执行，微任务一定是在宏任务之前执行的（和node v 11之前不太一样，node11之前微任务在事件循环执行的各个阶段执行）  
  step3：介绍nodejs的事件循环  
    6个阶段  
      Timers 定时器回调  
      Poll 轮询I/O回调  
      check setImmediate  
      Close socket close事件  
      Pending 系统回调  
      Idel 不可见，内部使用  
      与开发相关的主要是 timers 和 Poll 阶段  
        Timers同浏览器宏任务  
        Process.nextTick优先级高于其他微任务添加一个回调到下一个事件环队列，会在js堆栈执行完后，下一次事件循环前执行；  
        IO 轮询，计算 应该阻塞和轮询i/o的事件，然后处理轮询队列里面的事件  
  
# 执行上下文  
  变量和函数的上下文决定可以访问的数据和行为，每个函数都有执行上下文，当执行函数时，函数的上下文会被推入一个执行栈，然后再执行，执行完成后，把控制权返还给执行上下文；  
  作用域：函数执行时，会产生一个上下文的作用域，作用域决定可以访问的变量和和函数的顺序，作用域里面的可访问/操作对象来自包含的执行上下文，然后再上/下的活动对象包含执行上下文，即执行时会对其里面的函数和变量进行作用域链的查找，如果找不到就沿着作用域链一级一级网上找，直到作用域链的顶层未知；  
  
# 闭包  
  JS中，执行完上下文之后，其作用域也会被清除，内存也会被回收；  
  具体代码，函数A，返回了一个函数B或对象，对象的方法或函数B可以访问A的内部变量，即上级函数执行完后，产生了一个不会被销毁的作用域让B执行的时候可以访问到，就是闭包；  
  应用场景  
    面向对象中私有变量的实现；  
    高阶函数，防抖、节流、柯理话、高阶组件等；  
  
# 内存相关  
  step1：对js的内存有哪些了解，  
    分引用类型和基础数据类型，基础数据类型存放在栈内，引用类型存放在堆内存里  
    基础数据类型：string一个字符串长度占2字符，number数字8字符，boolean布尔类型4字符，null undefind 不占内存，symbol  
    引用数据类型：对象和数组和函数  
  step2: 实现一个sizeOf函数，计算一个值占的内存  
    写完问为何使用weakMap/weakSet不用其他  
      1、weakMap/weakSet对数据是弱引用，不同于Map/Set，当一个key是一个对象，改对象被删除引用时，weakMap指向这个key的引用也被回收掉，  
      2、weakMap的key只能使引用类型，用这个特性可以把数据中重复引用的数据指针过滤掉不计入内存占用；  
  step3：内存如何释放  
    gc垃圾回收机制，执行时，自动的对内存垃圾进行回收，将内存分为新生代和老生代，  
    新生代内存，没有被垃圾回收标记过的，老生代内存，垃圾回收标记过的；  
    引用计数，标记清理，标记整理，主要使用标记清理和标记整理；  
    标记清理，会对所有的对象打上一个标记，然后把再执行上下文中引用到的标记删除（但是已经执行过标记操作了），再下一次垃圾回收执行时，清理掉打上标记的，然后重复再打标记，释放掉带标记的内存，这个过程一直执行，由于内存时直接释放，所以内饰碎片是不连续的，当不连续的内存空间不足以分配一个大内存变量时，会提前触发垃圾回收；  
    标记整理，和标记清理不同的是不会直接清理标记的内存，会把内存往一边靠拢，类似windows的存储碎片整理，整理完后再释放引用内存  
  step4：知道隐藏类吗  
    只是了解，v8对内存做的优化，即对象创建时会生成一个隐藏类，结合inline-cache行内缓存可以快速的对 对象属性的进行访问，但是执行一些比如delete操作会对对象的访问序列产生更改，导致同一个隐藏类不可用；  
  